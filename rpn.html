<!DOCTYPE html>
<html lang="it-IT">
<head>
  <meta charset="utf-8" />
  <title>RPN-Calc</title>
  <link rel="stylesheet" href="style-rpn.css" />
  <style>
    button {
      font-size: x-small;
      height: 2em;
      width: 3em;
    }
  </style>
</head>
<body>
<h1>RPN CALC</h1>

<table id="myTable">
  <thead>
      <tr>
          <th>Stack <hr> </th>
      </tr>
  </thead>
  <tbody id="tableBody">
  </tbody>
</table>

<form onsubmit="calculate(); event.preventDefault();">
    <input type="text" id="expression" 
      onkeydown="
      if (event.keyCode === 13) { 
        eval(calculate);}"
      autocomplete="off"
      />
    <p id="message"></p>
</form>  

<button title="Sommatoria" onclick="sommatoria()">&#8512;</button>    
<button title="Potenza" onclick="potenza()">x<sup>y</sup></button>    
<button title="Inverso" onclick="inverso()">1/x</button>    
<button title="Cancella un elemento" onclick="cancella_elemento()">d</button>    
<button title="Cancella la stack" onclick="cancella_stack()">cls</button>    
<button title="Scambia X e Y" onclick="scambiaxy()">x&#8596;y</button>
<br>
<style>
  .keyboard {
    display: flex;
    flex-wrap: wrap;
  }
  .row {
    display: flex;
    width: 100%;
  }
  .keyboard button {
    width: 60px;
    height: 60px;
    border: 1px solid #333;
    background-color: #fff;
  }
</style>

<div class="keyboard">
  <div class="row">
    <button>7</button>
    <button>8</button>
    <button>9</button>
    <button>/</button>
  </div>
  <div class="row">
    <button>4</button>
    <button>5</button>
    <button>6</button>
    <button>*</button>
  </div>
  <div class="row">
    <button>1</button>
    <button>2</button>  
    <button>3</button>
    <button>-</button>
  </div>
  <div class="row">
  <button>0</button>
  <button>.</button>
  <button>C</button>
  <button>+</button>
  <button>=</button>
  </div>

  <!-- Add more buttons for the rest of the keyboard -->
</div>

<br>
<h2>Notazione polacca inversa</h2>
<p>Definita in Inglese come RPN (Reverse Polish Notation), è una notazione
che permette di eseguire calcoli complessi con pieno controllo delle precedenze.
</p>

<p>Se, per esempio devo moltiplicare un numero per una somma di due numeri,
con una calcolatrice scientifica devo utilizzare le parentesi per
eseguire la somma prima della moltiplicazione.</p>
<p> 3*(5+8)</p>
<p>Con la polacca inversa digiterò: 5 8+ 3*</p>
<p>Nella nostra calcolatrice digiterò:</p>
<ul>
  <li>5 &LessLess; invio &GreaterGreater;</li>
  <li> 8+&LessLess; invio &GreaterGreater;</li>
  <li> 3*&LessLess; invio &GreaterGreater;</li>
</ul>
<br>
<h2>Da sviluppare:</h2>
<ol>
  <li>Font e colori&#10003;</li>
  <li>Formato numeri con delimitazione migliaia e virgola fissa&#10003;</li>
  <li>Inserimento numeri con la virgola&#10003;</li>
  <li>Numeri allineati a destra &#10003;</li>
  <li>Input numeri negativi (per non confondere con - operatore) &#10003; <br> realizzato con operatore n</li>
  <li>Sommatoria della stack &#10003;</li>
  <li>Tastiera per tablet</li>
</ol>
<script>

let stack = [];
function rpn(expression){
  expression = expression.toLowerCase()
  if (expression === '') {
    message("Stringa vuota");
    return;
  }
  //message(expression)
  let tokens = expression.match(/\d+.\d+|.\d+|\d+|n|radq|somma|d|[\+\-\*\/\ \^]/g);
  if (!tokens){
    message("Espressione \""+expression+"\" non riconosciuta");
    return;
  }
  if (tokens.length === 0) {
    message("Espressione non riconoscuta: '"+ expression + "'")
  }
  //message(tokens);
  for (let token of tokens) {
    if (token === '' || token === ' ') continue;
    if (isNaN(token)) {
      // Operatori unari
      if (stack.length === 0) {
        message("Stack vuota!");
        return;
      };      
      switch (token) {
        case "d":
            stack.pop();
            continue;
        case "radq":
            let a = stack.pop();
            stack.push(Math.sqrt(a));
            continue;
        case "n":
          stack.push(-stack.pop());
          continue;
        case "somma":
          sommatoria();
          continue;
      };
      // Operatori binari
      if (stack.length < 2) {
        message("Stack insufficiente!");
        return;
        }
      let b = stack.pop();
      let a = stack.pop();
      switch (token) {
        case "+":
          stack.push(a + b);
          break;
        case "-":
          stack.push(a - b);
          break;
        case "*":
          stack.push(a * b);
          break;
        case "/":
          stack.push(a / b);
          break;
        case "^":
            stack.push(a ** b);
            break;
        default:
            message("Operatore '"+token+"' non riconosciuto.")
      }
    } else {
      stack.push(parseFloat(token));
    }
  }
}

function calculate() {
  let expression = document.getElementById("expression");
  rpn(expression.value);
  expression.value = "" ;
  stack_print();
}
/*
function stack_print() {
  let list = [ "c0", "c1", "c2", "c3"];
  let celle = [];
  const max_rows = 4
  for (let idc of list) { 
    celle.push( document.getElementById(idc))
  };

  mr = Math.min(stack.length, max_rows);
  for (let i = 0; i < mr; i++){
    celle[i].innerHTML = stack[i]
  }
}
*/

function stack_print(){
  var TableBody = document.getElementById("tableBody");
  const rows = TableBody.rows;
  if (rows) {
    while (rows.length>0) {
      TableBody.deleteRow(0)
    }
  }
  for(let i = 0; i < stack.length ; i++ ){
    var row = TableBody.insertRow();
    var cell = row.insertCell();
    cell.innerHTML = Number(stack[i].toFixed(2)).toLocaleString();
  }
  document.getElementById("expression").focus()
}

function message(msg){
    document.getElementById("message").innerHTML = '=> ' + msg 
}

function show(kc){
  message('Keycode = '+kc)
}

function pop(){
  stack.pop()
}

function sommatoria(){
  let acc = 0;
  while (stack.length){
    acc += stack.pop();
  }
  stack.push(acc);
  stack_print();
}

function potenza(){
  if (stack.length < 2){
    message("Stack insufficiente!");
    return;
  }
  let y = stack.pop()
  let x = stack.pop()
  if (y<0 && x===0){
    message("Divisione per 0.")
    return;
  }
  stack.push(x**y);
  stack_print();
}

function inverso(){
  if (stack.length === 0){
    message("Stack vuota!");
    return;
  }
  let x = stack.pop()
  if (x===0){
    message("Divisione per 0.")
    return;
  }
  stack.push(1/x);
  stack_print();
}

function cancella_elemento(){
  if (stack.length > 0){
    stack.pop();
  }
  stack_print();
}

function cancella_stack(){
  while (stack.length){
    stack.pop()
  }
  stack_print();
}

function scambiaxy(){
  x = stack.pop()
  y = stack.pop()
  stack.push(x)
  stack.push(y)
  stack_print();
}

const keyboard = document.querySelector(".keyboard");
const output = document.getElementById("expression");

keyboard.addEventListener("click", function(event) {
  if (event.target.tagName === "BUTTON") {
    const value = event.target.textContent;
    message(value)
    switch (value) {
      case "C":
        output.value = "";
        break;
      case "=":
        try {
          calculate();
        } catch (error) {
          message("Error");
        }
        break;
      default:
        output.value += value;
        output.focus()
        break;
    }
  }
});

</script>
</body>
</html>
